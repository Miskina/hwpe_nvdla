#!/usr/bin/env python3

from argparse import ArgumentParser
from datetime import datetime
import sys
import time
from typing import Dict, Iterable, List, NamedTuple
import os
# import numpy as np
from array import array
import re
from collections import defaultdict
from enum import Enum

from numpy import isinf

SCRIPT_NAME = os.path.basename(__file__)

CFG_EXT = '.cfg'
DAT_EXT = '.dat'
HEADER_EXT = '.h'

HEADER_FILE_COMMENT = \
"""


// Header file generated by the 'trace_test_to_c.py' Python
// script which generates header files required for testing NVDLA.
// Authors:
//      - Luka Macan <luka.macan@fer.hr>
//      - Mihael Kovaƒç <mihael.kovac@fer.hr>



"""


HEADER_FILE_INCLUDES = ['#include <nvdla.h>', '#include <stdint.h>']

ALL_TRACES_HEADER_NAME = 'nvdla_trace_tests.h'
ALL_TRACES_HEADER_INCLUDE_GUARD = 'HWPE_NVDLA_ALL_TRACES_H'

LOG_FORMAT = '{} - {}'
LOG_DATE_FORMAT = '%d-%m-%Y %H:%M:%S'

def _log_msg(msg):
    time = datetime.now().strftime(LOG_DATE_FORMAT)
    return LOG_FORMAT.format(time, msg)

def log(msg):
    print(_log_msg(msg))

def error(msg):
    print(_log_msg, file=sys.stderr)


class Trace:

    def __init__(self, trace_directory: str, name: str = None):
        self.directory = trace_directory
        self.name = name if name else os.path.basename(trace_directory) 
        self.cfg = os.path.join(self.directory, self.name + CFG_EXT)
        self.dat = os.path.join(self.directory, self.name + DAT_EXT)
        self.header = os.path.join(self.directory, self.name + HEADER_EXT)

class MemArray:

    def __init__(self, size: int):
        # self.arr = np.zeros(size, dtype=np.uint8)
        self.arr = array('B')
        self.arr.extend(size * [0])
        self.was_set = False
        self.name = None
        self.data_type = 'uint8_t'

    @property
    def size(self):
        return len(self.arr) 

    def set_values(self, address: int, values: Iterable[int], size: int = 0):
        if size == 0:
            size = len(values)
        if not isinstance(values, array):
            values = array('B', values)
        overflow = address + size - self.size
        if overflow > 0:
            self.arr.extend(overflow * [0])
            self.set_values(address, values, size)
        else:
            self.arr[address:address+size] = values
            self.was_set = self.was_set or max(values) > 0
    

class HeaderGenerator:

    def __init__(self, indent: int = 4):
        self.indent = indent
        self._current_indent = 0
        self.header_path = None
        self._include_guard = None
        self._header_file = None
        self._print = None    

    def function_start(self, return_type: str,
                       name: str, **kwargs):

        args_str = ', '.join([f'{arg_type} {arg}' for arg, arg_type in kwargs.items()])

        self._print(f'{return_type} {name}({args_str})')
        self._print(f'{"{"}')
        self._current_indent += self.indent

    
    def function_end(self):
        if self._current_indent <= 0:
            return
        self._current_indent -= self.indent
        self._print(f'{"}"}')
    
    def for_start(self, init: str, cond: str, step: str):
        self._print(f'for ({init}; {cond}; {step})')
        self._print(f'{"{"}')
        self._current_indent += self.indent
    
    def for_end(self):
        self.function_end()
    
    def if_start(self, cond: str):
        self._print(f'if ({cond})')
        self._print(f'{"{"}')
        self._current_indent += self.indent
    
    def if_end(self):
        self.function_end()
    
    def generate_array(self, arr: MemArray, entries_per_line: int = 4, attribute: str = None):
        attrib_str = ""
        if attribute:
            attrib_str = f'__attribute__(({attribute}))'
        self._print(f'{arr.data_type} {arr.name}[{arr.size}] {attrib_str} = {"" if arr.was_set else "{ 0 };"}')
        if arr.was_set:
            self._print('{')
            self._current_indent += self.indent
            n = len(arr.arr)
            for i in range(0, n, entries_per_line):
                arr_chunk = arr.arr[i:i+entries_per_line]
                arr_line = ", ".join([f'0x{val:02X}' for val in arr_chunk])
                if (i + entries_per_line + 1) < n:
                    arr_line += ','
                self._print(arr_line)
                
            self._current_indent -= self.indent
            self._print('};')
    
    def gen_line(self, line: str):
        self._print(line)
    
    def empty_line(self):
        self._print('')
    
    def line_comment(self, comment: str, indented=True):
        indent = self._current_indent if indented else 0
        comment = f'// {comment}'
        self._print(f'{comment:>{indent}}')
    
    def open(self, header_path: str, include_guard: str, includes: list = []):
        self.close()

        self.header_path = header_path 
        self._include_guard = include_guard
        self._header_file = open(self.header_path, 'w') 

        def _file_printer(msg):
            msg = f'{"":>{self._current_indent}}{msg}' 
            print(msg, file=self._header_file)
        
        self._print = _file_printer

        log(f'Starting generation of header file: {self.header_path}')

        self._print(f'#ifndef {self._include_guard}')
        self._print(f'#define {self._include_guard}')
        self._print(HEADER_FILE_COMMENT)
        for include in includes:
            self._print(include)
        self._print('')
        self._print('')
    

    def close(self):
        if not self.header_path:
            return
        
        log(f'Closing header file: {self.header_path}')

        if self._print:
            self._print(f'#endif // {self._include_guard}')
            self._print = None
        if self._header_file:
            self._header_file.close()
        self._current_indent = 0
        self.header_file_path = None
        self._include_guard = None

    
class TraceCommand(NamedTuple):
    name: str
    args: List[str]

class RegCommand(NamedTuple):
    cmd_type: str
    component: str
    register: str
    value: str

class Interrupt:

    def __init__(self, name: str, component: str, reg: int):
        self.name = name
        self.component = component
        self.reg = reg
        self.crc = 0
        self.address = 0
        self.size = 0
    
    def is_crc(self) -> bool:
        return self.crc != 0 and self.address

class TraceCompNames(str, Enum):
    SETUP_REGISTERS = 'setup_registers'
    FINISH = 'finish'
    INPUT_DATA = 'data'
    OUTPUT_SPACE = 'space'

        
class TraceHeaderGenerator:

    COMMAND_REGEX = re.compile('(\w+)\((.+)\);?')
    DATA_LINE_REGEX = re.compile('{offset:([\dxabcdef]+)\s*,\s*size:(\d+)\s*,\s*payload\s*:\s*([\s\dabcdefx]+)\s*}\s*,\s*', re.IGNORECASE)
    REGISTER_REGEX = re.compile('(\w+)\.(\w+)')
    COMMENT_REGEX = re.compile('\s*//.*')
    INTR_STATUS_REG = 'NVDLA_GLB_S_INTR_STATUS_0'
    DLA_CHECK_CRC = 'check_crc'
    WRITE_FUN = 'nvdla_write'
    READ_FUN = 'nvdla_read'

    def __init__(self, header_indent=4):
        self._header_generator = HeaderGenerator(indent=header_indent)
        self.command_handlers = {
            'mem_init': self._mem_init,
            'mem_load': self._mem_load,
            'reg_write': self._reg_write,
            'intr_notify': self._intr_notify,
            'check_crc': self._check_crc,
            'check_nothing': self._check_nothing,
            'poll_reg_equal': self._poll_reg_equal
        }
    
    def _read_trace_cfg(self):
        trace_cfg = open(self.trace.cfg, 'r')
        for line in trace_cfg:
            line = line.strip()
            if not line or TraceHeaderGenerator.COMMENT_REGEX.match(line):
                continue
            command_match = TraceHeaderGenerator.COMMAND_REGEX.search(line)
            trace_command = TraceCommand(command_match.group(1),
                                         [arg.strip() for arg in command_match.group(2).split(',')])

            log(f'Handling command - {line}')
            self.handle_command(trace_command)
        
        trace_cfg.close()
    
    def _gen_arrays(self):
        self.arrays = []
        arr_names_used = defaultdict(int) 
        for mem_arr in self.mem_arrays.values():
            mem_arr.name = f'{self.trace.name}_{TraceCompNames.INPUT_DATA if mem_arr.was_set else TraceCompNames.OUTPUT_SPACE}'
            name_count = arr_names_used[mem_arr.name]
            if name_count > 0:
                mem_arr.name = f'{mem_arr.name}_{name_count}'
            arr_names_used[mem_arr.name] = name_count + 1
            
            log(f'Generating array: {mem_arr.name}')
            self._header_generator.line_comment(f'Array generated using the "{SCRIPT_NAME}" tool')
            self._header_generator.generate_array(mem_arr, entries_per_line=8, attribute='section(".l2_data.nvdla")')
        
        arr_names_used.clear()
    
    def _gen_register_setup(self):
        self._header_generator.line_comment(f'Write register function generated using the "{SCRIPT_NAME}" tool')
        self._header_generator.function_start('int', f'{self.trace.name}_{TraceCompNames.SETUP_REGISTERS}')
        self._header_generator.gen_line('int result, i;')
        self._header_generator.empty_line()
        self._header_generator.line_comment(f'Assume passed if no register reads failed or only register writes called')
        self._header_generator.gen_line('result = 1;')
        self._header_generator.empty_line()
        for reg_command in self.reg_commands:
            component = reg_command.component  #  .split('_')[1]
            register = reg_command.register
            value = reg_command.value
            val_hex = int(value, 16)
            if val_hex in self.mem_arrays:
                arr_name = self.mem_arrays[val_hex].name
                value = f'(unsigned int)({arr_name})'
            if reg_command.cmd_type == 'read':
                self._header_generator.line_comment('Assume the read failed before the for loop')
                self._header_generator.gen_line('result = 0;')
                self._header_generator.for_start('i = 0', 'i < 10', '++i')
                self._header_generator.if_start(f'{value} == nvdla_{reg_command.cmd_type}({component}_{register})')
                self._header_generator.gen_line('result = 1;')
                self._header_generator.gen_line('break;')
                self._header_generator.if_end()
                self._header_generator.for_end()
                self._header_generator.line_comment('If the read failed - the test failed!')
                self._header_generator.if_start('!result')
                self._header_generator.gen_line('return 0;')
                self._header_generator.if_end()
            else:
                self._header_generator.gen_line(f'nvdla_{reg_command.cmd_type}({component}_{register}, {value});')
        
        self._header_generator.empty_line()
        self._header_generator.gen_line('return result;')
        
        self._header_generator.function_end()

    def _gen_finish(self):
        self._header_generator.line_comment(f'Finish function generated using the "{SCRIPT_NAME}" tool')
        self._header_generator.function_start('int', f'{self.trace.name}_{TraceCompNames.FINISH}')

        c_mask_var = 'intr_mask'
        c_result_var = 'result'
        self._header_generator.gen_line(f'uint32_t {c_mask_var};')
        self._header_generator.gen_line(f'int {c_result_var};')
        self._header_generator.empty_line()
        self._header_generator.gen_line(f'{c_mask_var} = 0;')
        self._header_generator.line_comment(f'Assume valid result unless CRC check fails!')
        self._header_generator.gen_line(f'{c_result_var} = 1;')

        for interrupt_name, interrupt in self.interrupts.items():
            interrupt_mask = f'{TraceHeaderGenerator.INTR_STATUS_REG}_{interrupt.component}_DONE_STATUS{interrupt.reg}_FIELD'
            self._header_generator.empty_line()
            self._header_generator.line_comment(f'Polling interrupt from {interrupt.component}_{interrupt.reg}')
            self._header_generator.gen_line(f'{c_mask_var} = {interrupt_mask};')
            self._header_generator.gen_line(f'while(({c_mask_var} & {TraceHeaderGenerator.READ_FUN}({TraceHeaderGenerator.INTR_STATUS_REG})) != {c_mask_var});')
            self._header_generator.gen_line(f'{TraceHeaderGenerator.WRITE_FUN}({TraceHeaderGenerator.INTR_STATUS_REG}, {interrupt_mask});')

            # TODO: Add interrupt clearing?
            if interrupt.is_crc():
                address = interrupt.address
                if address in self.mem_arrays:
                    arr = self.mem_arrays[address]
                    address_str = f'(uint8_t*)({arr.name})'
                else:
                    address_str = str(interrupt.address)
                self._header_generator.gen_line(f'{c_result_var} = {c_result_var} && check_crc({address_str}, {interrupt.size}u, {interrupt.crc}u);')

        self._header_generator.empty_line()
        self._header_generator.gen_line(f'return {c_result_var};')
        self._header_generator.function_end()

    def execute_trace(self, trace: Trace):
        log(f'Starting trace generation for trace: {trace.name} ({trace.directory})')
        self.mem_arrays = {} 
        self.reg_commands = []
        self.interrupts = {}
        self.trace = trace

        log(f'Reading trace configuration for: {trace.name} ({trace.directory})')
        self._read_trace_cfg()


        self._header_generator.open(self.trace.header, f'HWPE_NVDLA_TRACE_{self.trace.name}_H', HEADER_FILE_INCLUDES)
        
        log(f'Generating arrays')
        self._gen_arrays()

        self._header_generator.empty_line()
        
        log(f'Generating register setup function')
        self._gen_register_setup()

        log(f'Finished generating register write function')
        
        self._header_generator.empty_line()

        log(f'Generating interrupt poll function')
        self._gen_finish()
        log(f'Finished interrupt polling function generation')

        self._header_generator.empty_line()
        self._header_generator.empty_line()
        self._header_generator.close()
        log(f'Finished header generation for trace: {self.trace.name} ({trace.directory})')
        log(f'Generated header: {self.trace.header}')

    def _mem_init(self, trace_command: TraceCommand):
        
        assert trace_command.args[0] == 'pri_mem'
        address = int(trace_command.args[1], 16)
        size = int(trace_command.args[2], 16)
        value_command = trace_command.args[3]

        # TODO: Add error handling for last and first parameter

        if address not in self.mem_arrays:
            self.mem_arrays[address] = MemArray(size)

    def _mem_load(self, trace_command: TraceCommand):
        
        assert trace_command.args[0] == 'pri_mem'
        address = int(trace_command.args[1], 16)
        dat_file = trace_command.args[2]

        if address not in self.mem_arrays:
            # raise ValueError('mem_load function must have address of initialized memory, called with mem_init')
            self.mem_arrays[address] = MemArray(0)
        
        mem_arr = self.mem_arrays[address]

        dat_file_name = dat_file[1:-1] # Get rid of ""
        
        dat_file_path = os.path.join(self.trace.directory, dat_file_name)
        with open(dat_file_path, 'r') as dat_file:

            for data_line in dat_file:
                data_line = data_line.strip()

                if data_line.strip() == '}' or data_line.strip() == '{':
                    continue

                data_match = TraceHeaderGenerator.DATA_LINE_REGEX.match(data_line)
                offset = int(data_match.group(1), 16)
                size = int(data_match.group(2), 16)
                payload = [int(val, 16) for val in data_match.group(3).split(' ')]

                mem_arr.set_values(offset, payload, size)
        
    def _reg_write(self, trace_command: TraceCommand):
        register_str = trace_command.args[0]
        register_match = TraceHeaderGenerator.REGISTER_REGEX.match(register_str)

        component = register_match.group(1)
        register = register_match.group(2)
        value = trace_command.args[1]

        self.reg_commands.append(RegCommand('write', component, register, value))

    def _poll_reg_equal(self, trace_command: TraceCommand):
        register_str = trace_command.args[0]
        register_match = TraceHeaderGenerator.REGISTER_REGEX.match(register_str)
        component = register_match.group(1)
        register = register_match.group(2)
        value = trace_command.args[1]

        self.reg_commands.append(RegCommand('read', component, register, value))
    
    def _intr_notify(self, trace_command: TraceCommand):
        split_reg = trace_command.args[0].split('_')
        component, register = split_reg[0], int(split_reg[1])
        name = trace_command.args[1]
        self.interrupts[name] = Interrupt(name, component, register)
    
    def _check_crc(self, trace_command: TraceCommand):
        interrupt_name = trace_command.args[0]
        interrupt = self.interrupts[interrupt_name]
        poll_address = int(trace_command.args[2], 16)
        size = int(trace_command.args[3], 16)
        crc = int(trace_command.args[4], 16)

        interrupt.size = size
        interrupt.crc = crc
        interrupt.address = poll_address
    
    def _check_nothing(self, trace_command: TraceCommand):
        pass

        

    def handle_command(self, trace_command: TraceCommand):
        handler = self.command_handlers[trace_command.name]
        handler(trace_command)

class AllTraceHeaderMacros(str, Enum):
    TRACE_MACRO_VAR = 'HWPE_NVDLA_TRACE'
    SETUP_REGISTERS = 'TRACE_SETUP_REGISTERS'
    FINISH = 'TRACE_FINISH'
    INPUT_DATA = 'TRACE_INPUT_DATA'
    OUTPUT_SPACE = 'TRACE_OUTPUT_SPACE'
    LOG = 'TRACE_LOG'
    NAME = 'TRACE_NAME'

class AllTraceHeaderGenerator:
    
    def __init__(self, args):
        self.all_traces_header_path = ALL_TRACES_HEADER_NAME
        if args.all_traces_output:
            self.all_traces_header_path = os.path.join(args.all_traces_output, ALL_TRACES_HEADER_NAME)
        
        self._header_gen = HeaderGenerator()
        self._header_gen.open(self.all_traces_header_path, ALL_TRACES_HEADER_INCLUDE_GUARD)

    def add_trace_macros(self, trace: Trace, mem_arrays: Dict[int, MemArray]):
        self._header_gen.gen_line(f'#ifdef {trace.name.upper()}')
        self._header_gen.gen_line(f'#define {AllTraceHeaderMacros.TRACE_MACRO_VAR} {trace.name}')
        self._header_gen.gen_line(f'#include "{os.path.abspath(trace.header)}"')
        data_arr_count = 0
        out_arr_count = 0
        for i, arr in enumerate(mem_arrays.values()):
            if arr.was_set:
                name = AllTraceHeaderMacros.INPUT_DATA
                counter = data_arr_count
                data_arr_count += 1
            else:
                name = AllTraceHeaderMacros.OUTPUT_SPACE
                counter = out_arr_count
                out_arr_count += 1
            self._header_gen.gen_line(f'#define {name}{f"_{counter}" if counter > 0 else ""} {arr.name}')
        self._header_gen.gen_line(f'#endif // {trace.name.upper()}')
        self._header_gen.empty_line()
    
    def _concat_macro(self, name: str, concated: str):
        self._header_gen.gen_line(f'#define {name} _TRACE_EVAL_CONCAT({AllTraceHeaderMacros.TRACE_MACRO_VAR}, {concated})')

    def gen_util_macros(self):
        self._header_gen.empty_line()
        self._header_gen.gen_line(f'#ifndef {AllTraceHeaderMacros.TRACE_MACRO_VAR}')
        self._header_gen.gen_line('#error "No trace test specified!"')
        self._header_gen.gen_line(f'#endif // {AllTraceHeaderMacros.TRACE_MACRO_VAR}')
        self._header_gen.empty_line()

        self._header_gen.gen_line('#define _TRACE_CONCAT(first, second) first ## second')
        self._header_gen.gen_line('#define _TRACE_EVAL_CONCAT(x, y) _TRACE_CONCAT(x, y)')
        self._header_gen.gen_line(f'#define _TRACE_QUOTE(arg) #arg')
        self._header_gen.gen_line(f'#define _TRACE_STR(macro) _TRACE_QUOTE(macro)')
        self._header_gen.empty_line()

        self._header_gen.gen_line(f'#define {AllTraceHeaderMacros.NAME} _TRACE_STR({AllTraceHeaderMacros.TRACE_MACRO_VAR})')
        self._header_gen.gen_line(f'#define {AllTraceHeaderMacros.LOG}(format, ...) printf({AllTraceHeaderMacros.NAME} " - " format "\\n", ##__VA_ARGS__)')

        self._concat_macro(AllTraceHeaderMacros.SETUP_REGISTERS, f'_{TraceCompNames.SETUP_REGISTERS}')
        self._concat_macro(AllTraceHeaderMacros.FINISH, f'_{TraceCompNames.FINISH}')

        self._header_gen.empty_line()

    def close(self):
        if self._header_gen:
            self._header_gen.close()
            self._header_gen = None
            self.all_traces_header_path = None


def get_parser():

    parser = ArgumentParser(prog=SCRIPT_NAME,
                            description='Generate C header files from trace tests')

    parser.add_argument('-t', '--trace',
                        type=str,
                        nargs='*',
                        help='Specify a path to a trace test folder containing a ".cfg" file and (likely) a ".dat" file')
    parser.add_argument('-d', '--dir',
                        type=str,
                        nargs='*',
                        help='Specify a directory containing trace test folders')
    parser.add_argument('-a', '--all-traces-output',
                        type=str,
                        required=False,
                        dest='all_traces_output',
                        help=f'Specify where to output the "{ALL_TRACES_HEADER_NAME}" header, containing all header')


    return parser


def get_traces(directories: Iterable[str], traces: Iterable[str]) -> List[Trace]:

    all_traces = []
    if traces:
        for trace_directory in traces:
            all_traces.append(Trace(trace_directory))
    
    if not directories:
        return all_traces 
    
    for directory in directories:
        all_traces.extend([Trace(f.path, f.name) for f in os.scandir(directory) if f.is_dir()])

    return all_traces


def main(args):
    
    log('Acquiring all traces to be generated')
    traces = get_traces(args.dir, args.trace)

    all_traces_header_gen = AllTraceHeaderGenerator(args) 
    trace_generator = TraceHeaderGenerator()

    log('Starting trace generation...')
    start_time = time.perf_counter()

    for trace in traces:
        trace_generator.execute_trace(trace)
        all_traces_header_gen.add_trace_macros(trace, trace_generator.mem_arrays)

    log('Generating macros for all trace tests header file')
    all_traces_header_gen.gen_util_macros()
    all_traces_header_gen.close()

    end_time = time.perf_counter()

    log(f'Finished generating trace files in: {end_time - start_time}')
    

if __name__ == '__main__':
    
    parser = get_parser()

    args = parser.parse_args()

    if not (args.trace or args.dir):
        parser.error('No action requested. Specify at least one "-t" or "-d" parameter')

    main(args)
